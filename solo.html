<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RFE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; user-select: none; }
        
        /* UI LAYERS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; }
        
        #vignette { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, black 100%); z-index: 2; }
        #scanlines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0px, rgba(0,0,0,0.1) 1px, transparent 1px, transparent 2px); pointer-events: none; z-index: 3; }
        
        /* HUD */
        #hud-top { position: absolute; top: 20px; left: 20px; color: #fff; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000; z-index: 5; }
        #hud-bottom { position: absolute; bottom: 20px; left: 20px; color: #fff; font-size: 18px; z-index: 5; text-shadow: 1px 1px 0 #000; }
        
        #boss-hud { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 400px; display: none; z-index: 5; }
        #boss-hp-bar { width: 100%; height: 20px; background: #300; border: 2px solid #fff; }
        #boss-hp-fill { width: 100%; height: 100%; background: #f00; transition: width 0.2s; }
        #boss-name { text-align: center; color: red; font-weight: bold; margin-bottom: 5px; text-shadow: 1px 1px 0 #000; }

        .menu { background: rgba(0, 0, 0, 0.95); border: 2px solid #500; padding: 40px; text-align: center; color: #ccc; pointer-events: auto; max-width: 600px; }
        button { background: #800; color: #fff; border: 1px solid #f00; padding: 15px 30px; font-size: 1.5rem; cursor: pointer; font-family: inherit; margin-top: 20px; text-transform: uppercase; }
        button:hover { background: #c00; }
        .hidden { display: none !important; }

        .lore-text { color: #0f0; text-align: left; margin-bottom: 20px; font-size: 1.1em; line-height: 1.5; border-bottom: 1px dashed #0f0; padding-bottom: 20px; }
        h1 { color: #c00; font-size: 3em; margin: 0 0 20px 0; }

        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid rgba(0,255,0,0.5); border-radius: 50%; transform: translate(-50%, -50%); z-index: 4; display: none; }
        #hit-marker { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background: red; transform: translate(-50%, -50%) rotate(45deg); display: none; z-index: 5; }

        #scare-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black; display: none; z-index: 20; display: flex; align-items: center; justify-content: center; color: red; font-size: 5em; font-weight: bold; }
        
        #cheat-msg { position: absolute; top: 10px; right: 10px; color: yellow; font-weight: bold; opacity: 0; transition: opacity 0.5s; z-index: 100;}

        #mobile-controls { position: fixed; inset: auto 0 0 0; display: none; justify-content: space-between; padding: 16px; z-index: 50; pointer-events: none; }
        #mobile-move, #mobile-look { width: 180px; height: 180px; pointer-events: auto; }
        #mobile-move { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 6px; }
        .mobile-btn { border: 1px solid #f00; background: rgba(80, 0, 0, 0.65); color: #fff; font-size: 1.4rem; font-family: inherit; border-radius: 10px; }
        .mobile-btn:active, .mobile-btn.active { background: rgba(200, 0, 0, 0.9); }
        .blank { opacity: 0; pointer-events: none; }
        #mobile-look { border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 50%; position: relative; touch-action: none; }
        #mobile-look::after { content: 'LOOK'; position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.65); font-size: 0.8rem; letter-spacing: 1px; }
        #mobile-shoot { position: absolute; right: 20px; bottom: 210px; pointer-events: auto; width: 92px; height: 92px; border-radius: 50%; border: 2px solid #fff; background: rgba(160, 0, 0, 0.7); color: #fff; font-family: inherit; font-size: 0.9rem; display: none; }

        @media (pointer: coarse) {
            #mobile-controls { display: flex; }
            #hud-bottom { font-size: 16px; max-width: 60%; }
        }

        body.touch-device #mobile-controls { display: flex; }
        body.touch-device #hud-bottom { font-size: 16px; max-width: 60%; }
    </style>
</head>
<body>

    <div id="vignette"></div>
    <div id="scanlines"></div>
    <div id="crosshair"></div>
    <div id="hit-marker"></div>
    <div id="scare-overlay" class="hidden">CAUGHT</div>
    <div id="cheat-msg">CHEAT ENABLED: SKIPPING LEVEL...</div>

    <div id="hud-top">
        LEVEL: <span id="level-display">1</span><br>
        Files: <span id="paper-display">0/0</span>
    </div>
    
    <div id="boss-hud">
        <div id="boss-name">Kill Epstein</div>
        <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
    </div>

    <div id="hud-bottom">WASD to Move. Mouse to Look.<br><span style="font-size: 0.8em; color: #888;"></span></div>

    <div id="mobile-controls">
        <div id="mobile-move">
            <div class="blank"></div>
            <button class="mobile-btn" data-move="f">▲</button>
            <div class="blank"></div>
            <button class="mobile-btn" data-move="l">◀</button>
            <div class="blank"></div>
            <button class="mobile-btn" data-move="r">▶</button>
            <div class="blank"></div>
            <button class="mobile-btn" data-move="b">▼</button>
            <div class="blank"></div>
        </div>
        <div id="mobile-look"></div>
        <button id="mobile-shoot">SHOOT</button>
    </div>

    <div id="ui-layer">
        <div id="start-screen" class="menu">
            <h1>Epsteins Maze</h1>
            <p><strong>MISSION:</strong> Retrieve The Epstein Files.</p>
            <p><strong>WARNING:</strong> Epstein Will Try And Stop You At All Costs.</p>
            <button id="btn-start">Enter</button>
        </div>

        <div id="lore-screen" class="menu hidden">
            <h2 style="color: #0f0;">ENCRYPTED LOG <span id="log-id">#001</span></h2>
            <div id="lore-content" class="lore-text"></div>
            <button id="btn-continue-lore">PROCEED</button>
        </div>
        
        <div id="pause-screen" class="menu hidden">
            <h1 style="color:#aaa">PAUSED</h1>
            <button id="btn-resume">RESUME</button>
        </div>

        <div id="game-over" class="menu hidden">
            <h1 style="color:red">TERMINATED</h1>
            <button onclick="location.reload()">Restart Protocol</button>
        </div>

        <div id="victory-screen" class="menu hidden">
            <h1 style="color:gold">You Did It!!!</h1>
            <p>You have defeated Epstein and exposed the truth.</p>
            <button onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- LORE ---
        const LORE = {
            1: "ENTRY #1: It seems that Bill Clinton is on the list.",
            2: "ENTRY #2: TRUMP.",
            3: "ENTRY #3: You know to much your not gonna make it out alive....",
            4: "ENTRY #4: Beef is the only way to end this....",
            5: "ENTRY #5: He might try a different approach."
        };

        // --- AUDIO ---
        const AudioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let musicNodes = [];

        function startAmbientMusic() {
            if (AudioCtx.state === 'suspended') AudioCtx.resume();
            if (musicNodes.length > 0) return; 

            const freqs = [55, 110, 112]; 
            freqs.forEach(f => {
                const osc = AudioCtx.createOscillator();
                const gain = AudioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(f, AudioCtx.currentTime);
                const filter = AudioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, AudioCtx.currentTime);
                const lfo = AudioCtx.createOscillator();
                lfo.frequency.value = 0.1 + Math.random() * 0.2;
                const lfoGain = AudioCtx.createGain();
                lfoGain.gain.value = 0.02; 
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(AudioCtx.destination);
                lfo.connect(lfoGain);
                lfoGain.connect(gain.gain);
                gain.gain.setValueAtTime(0.05, AudioCtx.currentTime); 
                osc.start();
                lfo.start();
                musicNodes.push(osc, lfo);
            });
        }

        function playSound(type) {
            if (AudioCtx.state === 'suspended') AudioCtx.resume();
            const now = AudioCtx.currentTime;
            
            // MASTER GAIN
            const gain = AudioCtx.createGain();
            gain.connect(AudioCtx.destination);

            if (type === 'step') {
                const osc = AudioCtx.createOscillator();
                osc.connect(gain);
                osc.frequency.setValueAtTime(40, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            } else if (type === 'paper') {
                const osc = AudioCtx.createOscillator();
                osc.connect(gain);
                osc.frequency.setValueAtTime(600, now);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'shot') {
                const osc = AudioCtx.createOscillator();
                osc.connect(gain);
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'hit') {
                const osc = AudioCtx.createOscillator();
                osc.connect(gain);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'cheat') {
                const osc = AudioCtx.createOscillator();
                osc.connect(gain);
                osc.frequency.setValueAtTime(1200, now);
                gain.gain.setValueAtTime(0.1, now);
                osc.frequency.linearRampToValueAtTime(2000, now + 0.1);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'jumpscare') {
                // JUMPSCARE: Multiple oscillators for dissonant scream
                const osc1 = AudioCtx.createOscillator();
                const osc2 = AudioCtx.createOscillator();
                
                osc1.type = 'sawtooth';
                osc2.type = 'square';
                
                // Dissonant frequencies sliding down
               osc1.frequency.setValueAtTime(40, now);
osc1.frequency.exponentialRampToValueAtTime(60, now + 1);

osc2.frequency.setValueAtTime(43, now);
osc2.frequency.exponentialRampToValueAtTime(70, now + 1);

                gain.gain.setValueAtTime(1, now); // LOUD
                gain.gain.exponentialRampToValueAtTime(0.10, now + 0.5);

                osc1.connect(gain);
                osc2.connect(gain);
                
                osc1.start(now); osc1.stop(now + 0.4);
                osc2.start(now); osc2.stop(now + 0.4);
            }
        }

        const CONFIG = { TILE: 10, SPEED: 40.0, RUN_SPEED: 80.0, BOSS_HP: 180 };
        let state = { level: 1, papers: 0, totalPapers: 0, active: false, boost: false, mode: 'MAZE', bossHP: 180, bossPhase: 1, lastShot: 0 };
        let ignorePause = false;

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 0, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.PointLight(0xffffff, 1, 40);
        camera.add(light);
        scene.add(camera);

        // --- ASSET GENERATORS (Fallbacks) ---
        function getGunFallback() {
            const c = document.createElement('canvas'); c.width=128; c.height=128;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#444'; ctx.fillRect(40, 60, 48, 68); 
            ctx.fillStyle = '#666'; ctx.fillRect(30, 40, 68, 40); 
            ctx.fillStyle = '#0ff'; ctx.fillRect(40, 45, 10, 30); 
            ctx.fillStyle = '#222'; ctx.fillRect(48, 20, 32, 20); 
            ctx.strokeStyle = '#000'; ctx.lineWidth=4; ctx.strokeRect(48,20,32,20);
            return new THREE.CanvasTexture(c);
        }

        function getBulletFallback() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,5, 32,32,30);
            g.addColorStop(0, 'white');
            g.addColorStop(0.5, 'red');
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        const loader = new THREE.TextureLoader();

        // LOAD WEAPON.PNG
        const texGun = loader.load('groundbeef.png', (t)=>{ t.magFilter = THREE.NearestFilter; }, undefined, (err)=>{
            texGun.image = getGunFallback().image;
            texGun.needsUpdate = true;
            texGun.magFilter = THREE.NearestFilter;
        });

        // LOAD BULLET.PNG
        const texBullet = loader.load('groundbeef.png', (t)=>{ t.magFilter = THREE.NearestFilter; }, undefined, (err)=>{
            texBullet.image = getBulletFallback().image;
            texBullet.needsUpdate = true;
            texBullet.magFilter = THREE.NearestFilter;
        });

        const weaponMat = new THREE.SpriteMaterial({ map: texGun, depthTest: false }); 
        const weapon = new THREE.Sprite(weaponMat);
        weapon.scale.set(0.5, 0.5, 1);
        weapon.position.set(0.5, -0.6, -1.2); 
        weapon.renderOrder = 999;
        camera.add(weapon);
        weapon.visible = false;

        const controls = new PointerLockControls(camera, document.body);
        let move = { f: false, b: false, l: false, r: false };
        const isTouchDevice = window.matchMedia('(pointer: coarse)').matches || navigator.maxTouchPoints > 0 || 'ontouchstart' in window;
        const lookPad = document.getElementById('mobile-look');
        const shootBtn = document.getElementById('mobile-shoot');
        let activeLookTouchId = null;
        let lastLook = { x: 0, y: 0 };

        if (isTouchDevice) {
            document.body.classList.add('touch-device');
            document.getElementById('hud-bottom').innerText = 'TOUCH PAD TO MOVE / LOOK. TAP SHOOT IN BOSS FIGHT.';
        }

        function setMoveFlag(dir, pressed) {
            if (move[dir] === undefined) return;
            move[dir] = pressed;
        }

        function bindMoveButton(btn) {
            const dir = btn.dataset.move;
            const start = (e) => { e.preventDefault(); setMoveFlag(dir, true); btn.classList.add('active'); };
            const end = (e) => { e.preventDefault(); setMoveFlag(dir, false); btn.classList.remove('active'); };
            btn.addEventListener('touchstart', start, { passive: false });
            btn.addEventListener('touchend', end, { passive: false });
            btn.addEventListener('touchcancel', end, { passive: false });
            btn.addEventListener('pointerdown', start);
            btn.addEventListener('pointerup', end);
            btn.addEventListener('pointerleave', end);
        }

        document.querySelectorAll('#mobile-move .mobile-btn').forEach(bindMoveButton);

        lookPad.addEventListener('touchstart', (e) => {
            if (activeLookTouchId !== null) return;
            const t = e.changedTouches[0];
            activeLookTouchId = t.identifier;
            lastLook.x = t.clientX;
            lastLook.y = t.clientY;
            e.preventDefault();
        }, { passive: false });

        lookPad.addEventListener('touchmove', (e) => {
            if (activeLookTouchId === null) return;
            for (const t of e.changedTouches) {
                if (t.identifier !== activeLookTouchId) continue;
                const dx = t.clientX - lastLook.x;
                const dy = t.clientY - lastLook.y;
                controls.getObject().rotation.y -= dx * 0.003;
                camera.rotation.x -= dy * 0.003;
                camera.rotation.x = Math.max(-1.3, Math.min(1.3, camera.rotation.x));
                lastLook.x = t.clientX;
                lastLook.y = t.clientY;
                break;
            }
            e.preventDefault();
        }, { passive: false });

        lookPad.addEventListener('touchend', (e) => {
            for (const t of e.changedTouches) {
                if (t.identifier === activeLookTouchId) activeLookTouchId = null;
            }
        });

        shootBtn.addEventListener('touchstart', (e) => {
            if (state.mode === 'BOSS') shoot();
            e.preventDefault();
        }, { passive: false });

        function isMenuVisible(id) {
            return !document.getElementById(id).classList.contains('hidden');
        }

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.code === 'Backquote') {
                const msg = document.getElementById('cheat-msg');
                msg.style.opacity = 1;
                setTimeout(() => msg.style.opacity = 0, 2000);
                playSound('cheat');
                document.getElementById('pause-screen').classList.add('hidden');
                buildLevel(state.level + 1);
                return;
            }

            if (e.code === 'Enter') {
                if (isMenuVisible('start-screen')) {
                    document.getElementById('btn-start').click();
                    e.preventDefault();
                    return;
                }
                if (isMenuVisible('lore-screen')) {
                    document.getElementById('btn-continue-lore').click();
                    e.preventDefault();
                    return;
                }
                if (isMenuVisible('pause-screen')) {
                    document.getElementById('btn-resume').click();
                    e.preventDefault();
                    return;
                }
            }

            switch(e.code) {
                case 'KeyW': move.f = true; break;
                case 'KeyS': move.b = true; break;
                case 'KeyA': move.l = true; break;
                case 'KeyD': move.r = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': move.f = false; break;
                case 'KeyS': move.b = false; break;
                case 'KeyA': move.l = false; break;
                case 'KeyD': move.r = false; break;
            }
        });
        document.addEventListener('mousedown', () => { if(state.mode === 'BOSS') shoot(); });

        controls.addEventListener('unlock', () => {
            if (ignorePause) { ignorePause = false; return; }
            if (state.active) {
                document.getElementById('pause-screen').classList.remove('hidden');
                move = { f: false, b: false, l: false, r: false };
            }
        });

        document.getElementById('btn-resume').onclick = () => {
            document.getElementById('pause-screen').classList.add('hidden');
            state.active = true;
            controls.lock();
        };

        function getTex(col) {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            ctx.fillStyle = col; ctx.fillRect(0,0,32,32);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            if(Math.random()>0.5) ctx.fillRect(0,0,16,16);
            if(Math.random()>0.5) ctx.fillRect(16,16,16,16);
            return new THREE.CanvasTexture(c);
        }
        const texWall = getTex('#444');
        const texFloor = getTex('#111');
        const texMonster = loader.load('pdf.png', ()=>{}, ()=>{}, ()=>texMonster.image=getTex('red').image);
        texMonster.magFilter = THREE.NearestFilter;


        function makeBossPhaseTexture(imagePath) {
    const tex = loader.load(imagePath);
    tex.magFilter = THREE.NearestFilter;
    tex.colorSpace = THREE.SRGBColorSpace;
    return tex;
}

        
        const texBossPhase2A = makeBossPhaseTexture('boss_phase2.png');
        const texBossPhase2B = makeBossPhaseTexture('boss_phase2_alt.png');
        const texBossPhase3 = makeBossPhaseTexture('boss_phase3.png');
        
        let mapData = [];
        let width = 20, height = 20;
        let items = [];
        let projectiles = [];
        let monster = null;
        let exitObj = null;
        let bossTimers = { direct: 0, ring: 0, dash: 0, spiral: 0 };
        let bossA = null, bossB = null, bossC = null;

        function showLore(lvl) {
            if (LORE[lvl]) {
                document.getElementById('lore-content').innerText = LORE[lvl];
                document.getElementById('log-id').innerText = "#00" + lvl;
                document.getElementById('lore-screen').classList.remove('hidden');
                document.getElementById('pause-screen').classList.add('hidden');
                document.getElementById('ui-layer').style.pointerEvents = "auto";
            } else {
                startLevel(lvl);
            }
        }

        document.getElementById('btn-continue-lore').onclick = () => {
            document.getElementById('lore-screen').classList.add('hidden');
            document.getElementById('ui-layer').style.pointerEvents = "none";
            startLevel(state.level);
        };

        function buildLevel(lvl) {
            state.level = lvl;
            state.active = false;
            ignorePause = true; 
            document.exitPointerLock();
            document.getElementById('pause-screen').classList.add('hidden');

            if (lvl === 6) {
                setTimeout(() => startBossFight(), 100);
            } else {
                showLore(lvl);
            }
        }

        function startLevel(lvl) {
            state.active = true;
            state.mode = 'MAZE';
            state.papers = 0;
            state.totalPapers = 2 + lvl;
            
            document.getElementById('level-display').innerText = lvl;
            document.getElementById('paper-display').innerText = `0/${state.totalPapers}`;
            document.getElementById('hud-top').classList.remove('hidden');
            document.getElementById('boss-hud').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            shootBtn.style.display = 'none';
            weapon.visible = false;
                        scene.fog.far = 60;

            controls.lock();

            while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            scene.add(camera);

            width = 20 + (lvl * 4);
            height = 20 + (lvl * 4);
            mapData = new Array(height).fill(0).map(() => new Array(width).fill(1));

            function carve(x, y) {
                mapData[y][x] = 0;
                const dirs = [[0,-2],[0,2],[-2,0],[2,0]].sort(()=>Math.random()-0.5);
                for(let d of dirs) {
                    const nx = x + d[0], ny = y + d[1];
                    if(nx>0 && nx<width-1 && ny>0 && ny<height-1 && mapData[ny][nx]===1) {
                        mapData[y+d[1]/2][x+d[0]/2] = 0;
                        carve(nx, ny);
                    }
                }
            }
            carve(1,1);
            for(let i=0; i<width*2; i++) {
                let rx = Math.floor(Math.random()*(width-2))+1;
                let ry = Math.floor(Math.random()*(height-2))+1;
                mapData[ry][rx] = 0;
            }

            const geoBox = new THREE.BoxGeometry(CONFIG.TILE, 12, CONFIG.TILE);
            const matWall = new THREE.MeshBasicMaterial({ map: texWall });
            const geoFloor = new THREE.PlaneGeometry(CONFIG.TILE, CONFIG.TILE);
            const matFloor = new THREE.MeshBasicMaterial({ map: texFloor });

            let empties = [];
            items = [];

            for(let y=0; y<height; y++) {
                for(let x=0; x<width; x++) {
                    const px = (x - width/2) * CONFIG.TILE;
                    const pz = (y - height/2) * CONFIG.TILE;
                    
                    const f = new THREE.Mesh(geoFloor, matFloor);
                    f.rotation.x = -Math.PI/2;
                    f.position.set(px, 0, pz);
                    scene.add(f);
                    const c = f.clone();
                    c.position.y = 12;
                    c.rotation.x = Math.PI/2;
                    scene.add(c);

                    if (mapData[y][x] === 1) {
                        const w = new THREE.Mesh(geoBox, matWall);
                        w.position.set(px, 6, pz);
                        scene.add(w);
                    } else {
                        empties.push({x: px, z: pz});
                    }
                }
            }

            const start = empties[0];
            camera.position.set(start.x, 5, start.z);
            empties.shift();
            empties.sort(() => Math.random() - 0.5);

            for(let i=0; i<state.totalPapers; i++) {
                const spot = empties.pop();
                const cvs = document.createElement('canvas'); cvs.width=64;cvs.height=64;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle='#eee'; ctx.fillRect(10,10,44,54);
                ctx.fillStyle='black'; ctx.font="30px Arial"; ctx.fillText("?", 20, 50);
                const spr = new THREE.Sprite(new THREE.SpriteMaterial({map: new THREE.CanvasTexture(cvs)}));
                spr.scale.set(3,4,1);
                spr.position.set(spot.x, 5, spot.z);
                scene.add(spr);
                items.push(spr);
            }

            const exitSpot = empties.pop();
            const exitGeo = new THREE.BoxGeometry(2, 10, 2);
            exitObj = new THREE.Mesh(exitGeo, new THREE.MeshBasicMaterial({color: 0x550000}));
            exitObj.position.set(exitSpot.x, 5, exitSpot.z);
            scene.add(exitObj);

            const mSpot = empties[0];
            monster = new THREE.Sprite(new THREE.SpriteMaterial({map: texMonster, color: 0xffffff}));
            monster.scale.set(8,10,1);
            monster.position.set(mSpot.x, 5, mSpot.z);
            scene.add(monster);
        }


        function getActiveBosses() {
            if (state.bossPhase === 1) return bossA ? [bossA] : [];
            if (state.bossPhase === 2) return [bossA, bossB].filter(Boolean);
            return bossC ? [bossC] : [];
        }

        function enterBossPhase(phase) {
            state.bossPhase = phase;
            if (phase === 2) {
                if (bossA) scene.remove(bossA);
                bossA = new THREE.Sprite(new THREE.SpriteMaterial({ map: texBossPhase2A, color: 0xffffff }));
                bossA.scale.set(8, 8, 1);
                bossA.position.set(-0, 5, -60);
                scene.add(bossA);

                bossB = new THREE.Sprite(new THREE.SpriteMaterial({ map: texBossPhase2B, color: 0xffffff }));
                bossB.scale.set(8, 8, 1);
                bossB.position.set(0, 5, -60);
                scene.add(bossB);

                document.getElementById('hud-bottom').innerText = 'PHASE 2: TWO BOSSES. DODGE MULTI-SHOT.';
            } else if (phase === 3) {
                if (bossA) scene.remove(bossA);
                if (bossB) scene.remove(bossB);
                bossA = null; bossB = null;

                bossC = new THREE.Sprite(new THREE.SpriteMaterial({ map: texBossPhase3, color: 0xffffff }));
                bossC.scale.set(8, 8, 1);
                bossC.position.set(0, 5, -60);
                scene.add(bossC);
                document.getElementById('hud-bottom').innerText = 'PHASE 3: FINAL CHASER. KEEP MOVING.';
            } else {
                document.getElementById('hud-bottom').innerText = 'PHASE 1: NORMAL BOSS.';
            }
        }

        function spawnMultiShot(source, target, count, spreadRad, speed, color) {
            const base = new THREE.Vector3().subVectors(target, source.position).setY(0).normalize();
            const baseAngle = Math.atan2(base.z, base.x);
            for (let i = 0; i < count; i++) {
                const t = count === 1 ? 0 : (i / (count - 1) - 0.5);
                const angle = baseAngle + t * spreadRad;
                spawnBossProjectile(source, new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)), speed, color, 2.7);
            }
        }

        function startBossFight() {
            state.active = true;
            state.mode = 'BOSS';
            state.bossHP = CONFIG.BOSS_HP;
            state.bossPhase = 1;
            projectiles = [];
            bossTimers = { direct: 0, ring: 0, dash: 0, spiral: 0 };
            bossA = null; bossB = null; bossC = null;
            
            document.getElementById('hud-top').classList.add('hidden');
            document.getElementById('boss-hud').style.display = 'block';
            document.getElementById('level-display').innerText = "6 (BOSS)";
            document.getElementById('hud-bottom').innerText = isTouchDevice ? "TAP SHOOT. USE PILLARS FOR COVER." : "LEFT CLICK TO SHOOT. USE PILLARS FOR COVER.";
            document.getElementById('crosshair').style.display = 'block';
            shootBtn.style.display = isTouchDevice ? 'block' : 'none';
            weapon.visible = true;
                        scene.fog.far = 200;

            controls.lock();

            while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            scene.add(camera);

            const geoFloor = new THREE.PlaneGeometry(200, 200);
            const matFloor = new THREE.MeshBasicMaterial({ color: 0x220000 });
            const floor = new THREE.Mesh(geoFloor, matFloor);
            floor.rotation.x = -Math.PI/2;
            scene.add(floor);

            const geoPillar = new THREE.BoxGeometry(10, 30, 10);
            const matPillar = new THREE.MeshBasicMaterial({ color: 0x333333 }); 
            
            const pillarLocs = [[-40,-40], [40,-40], [-40,40], [40,40]];
            for(let p of pillarLocs) {
                const mesh = new THREE.Mesh(geoPillar, matPillar);
                mesh.position.set(p[0], 15, p[1]);
                mesh.name = "pillar";
                scene.add(mesh);
            }

            bossA = new THREE.Sprite(new THREE.SpriteMaterial({map: texMonster, color: 0xff5555}));
            bossA.scale.set(8, 8, 1);
            bossA.position.set(0, 5, -60);
            bossA.name = "BOSS";
            scene.add(bossA);
            monster = bossA;
            enterBossPhase(1);

            camera.position.set(0, 5, 80);
            camera.lookAt(bossA.position);
        }

        function spawnBossProjectile(source, direction, speed, color = 0xff4444, scale = 3) {
            const ball = new THREE.Sprite(new THREE.SpriteMaterial({ map: texBullet, color }));
            ball.scale.set(scale, scale, 1);
            ball.position.copy(source.position);
            ball.userData.vel = direction.normalize().multiplyScalar(speed);
            ball.userData.friendly = false;
            scene.add(ball);
            projectiles.push(ball);
        }

        function spawnRingBurst(count, speed, color = 0xff3333) {
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const source = getActiveBosses()[0];
                if (source) spawnBossProjectile(source, new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)), speed, color, 2.4);
            }
        }

        function updateBossHP(amount) {
            state.bossHP = Math.max(0, state.bossHP - amount);
            const pct = (state.bossHP / CONFIG.BOSS_HP) * 100;
            document.getElementById('boss-hp-fill').style.width = pct + '%';

            if (state.bossPhase === 1 && state.bossHP <= CONFIG.BOSS_HP * 0.66) {
                enterBossPhase(2);
            } else if (state.bossPhase === 2 && state.bossHP <= CONFIG.BOSS_HP * 0.33) {
                enterBossPhase(3);
            }

            if (state.bossHP <= 0) {
                state.active = false;
                document.exitPointerLock();
                document.getElementById('victory-screen').classList.remove('hidden');
                shootBtn.style.display = 'none';
            }
        }

        function shoot() {
            if (!state.active || state.mode !== 'BOSS') return;
            const now = Date.now();
            if (now - state.lastShot < 320) return;
            state.lastShot = now;

            weapon.position.y = -0.5;
            weapon.position.z = -1.1;
            setTimeout(() => {
                weapon.position.y = -0.6;
                weapon.position.z = -1.2;
            }, 100);

            playSound('shot');

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const targets = getActiveBosses();
            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                const hitBoss = intersects[0].object;
                hitBoss.material.color.setHex(0xffffff);
                setTimeout(()=>hitBoss.material.color.setHex(0xffffff), 100);
                playSound('hit');
                updateBossHP(4);
                const hm = document.getElementById('hit-marker');
                hm.style.display = 'block';
                setTimeout(()=>hm.style.display='none', 100);
            }
        }

        const clock = new THREE.Clock();

        function checkWall(x, z) {
            if (state.mode === 'MAZE') {
                const gx = Math.round((x / CONFIG.TILE) + width/2);
                const gy = Math.round((z / CONFIG.TILE) + height/2);
                if (gx < 0 || gx >= width || gy < 0 || gy >= height) return true;
                if (mapData[gy][gx] === 1) {
                    const tx = (gx - width/2) * CONFIG.TILE;
                    const tz = (gy - height/2) * CONFIG.TILE;
                    if (Math.abs(x-tx)<(CONFIG.TILE/2+1) && Math.abs(z-tz)<(CONFIG.TILE/2+1)) return true;
                }
            } else {
                if (Math.abs(x) > 95 || Math.abs(z) > 95) return true;
                for(let c of scene.children) {
                    if (c.name === "pillar") {
                        if (Math.abs(x - c.position.x) < 6 && Math.abs(z - c.position.z) < 6) return true;
                    }
                }
            }
            return false;
        }

        function update() {
            if (!state.active) return;
            const delta = Math.min(clock.getDelta(), 0.1);
            
            if (controls.isLocked) {
                const speed = state.boost ? CONFIG.RUN_SPEED : CONFIG.SPEED;
                const fwd = new THREE.Vector3();
                const right = new THREE.Vector3();
                camera.getWorldDirection(fwd);
                fwd.y = 0; fwd.normalize();
                right.crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();

                const vel = new THREE.Vector3();
                if (move.f) vel.add(fwd);
                if (move.b) vel.sub(fwd);
                if (move.r) vel.add(right);
                if (move.l) vel.sub(right);

                if (vel.lengthSq() > 0) {
                    vel.normalize().multiplyScalar(speed * delta);
                    if (!checkWall(camera.position.x + vel.x, camera.position.z)) camera.position.x += vel.x;
                    if (!checkWall(camera.position.x, camera.position.z + vel.z)) camera.position.z += vel.z;
                    camera.position.y = 5 + Math.sin(Date.now()*0.015)*0.2;
                }
            }

            if (state.mode === 'MAZE') {
                for(let i=items.length-1; i>=0; i--) {
                    if (camera.position.distanceTo(items[i].position) < 5) {
                        state.papers++;
                        document.getElementById('paper-display').innerText = `${state.papers}/${state.totalPapers}`;
                        playSound('paper');
                        scene.remove(items[i]);
                        items.splice(i, 1);
                        if (state.papers >= state.totalPapers) {
                            exitObj.material.color.setHex(0x00ff00);
                            buildLevel(state.level + 1);
                            break;
                        }
                    }
                }
                const dist = camera.position.distanceTo(monster.position);
                const dir = new THREE.Vector3().subVectors(camera.position, monster.position).normalize();
                const mSpeed = (dist < 30) ? 14 : 6;
                monster.position.add(dir.multiplyScalar(mSpeed * delta));
                if (dist < 3) gameOver();

            } else {
                const now = Date.now();
                const time = now * 0.001;

                if (state.mode === 'BOSS') {
                    const active = getActiveBosses();

                    if (state.bossPhase === 1 && bossA) {
                        bossA.position.x = Math.sin(time * 1.2) * 45;
                        bossA.position.z = Math.cos(time * 0.6) * 30 - 35;
                        if (now - bossTimers.direct > 800) {
                            bossTimers.direct = now;
                            spawnMultiShot(bossA, camera.position, 1, 0, 40, 0xff8844);
                        }
                    } else if (state.bossPhase === 2) {
                        if (bossA) {
                            bossA.position.x = Math.sin(time * 1.3) * 34 - 18;
                            bossA.position.z = Math.cos(time * 1.0) * 20 - 35;
                        }
                        if (bossB) {
                            bossB.position.x = Math.cos(time * 1.1) * 34 + 18;
                            bossB.position.z = Math.sin(time * 1.2) * 20 - 35;
                        }
                        if (now - bossTimers.direct > 900) {
                            bossTimers.direct = now;
                            for (const b of active) spawnMultiShot(b, camera.position, 5, Math.PI / 2.7, 36, 0xffcc33);
                        }
                    } else if (state.bossPhase === 3 && bossC) {
                        const chase = new THREE.Vector3().subVectors(camera.position, bossC.position).setY(0).normalize();
                        bossC.position.add(chase.multiplyScalar(18 * delta));
                        if (now - bossTimers.direct > 450) {
                            bossTimers.direct = now;
                            spawnMultiShot(bossC, camera.position, 3, Math.PI / 5, 44, 0xff3377);
                        }
                    }

                    for (const b of active) {
                        if (camera.position.distanceTo(b.position) < 7) { gameOver(); return; }
                    }
                }

                for(let i=projectiles.length-1; i>=0; i--) {
                    const p = projectiles[i];
                    p.position.add(p.userData.vel.clone().multiplyScalar(delta));

                    if (p.position.distanceTo(camera.position) < 3.4) {
                        scene.remove(p);
                        projectiles.splice(i,1);
                        gameOver();
                        return;
                    }

                    let hitPillar = false;
                    for(let c of scene.children) {
                        if (c.name === "pillar") {
                            if (Math.abs(p.position.x - c.position.x) < 5 && Math.abs(p.position.z - c.position.z) < 5) {
                                hitPillar = true;
                            }
                        }
                    }

                    if (hitPillar || p.position.length() > 240) {
                        scene.remove(p);
                        projectiles.splice(i,1);
                    }
                }
            }
        }

        function gameOver() {
            state.active = false;
                        document.exitPointerLock();
            shootBtn.style.display = 'none';
            document.getElementById('scare-overlay').classList.remove('hidden');
            playSound('jumpscare'); // PLAY JUMPSCARE SOUND
            setTimeout(() => {
                document.getElementById('scare-overlay').classList.add('hidden');
                document.getElementById('game-over').classList.remove('hidden');
            }, 1000);
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        document.getElementById('btn-start').onclick = () => {
            document.getElementById('start-screen').classList.add('hidden');
            startAmbientMusic(); 
            buildLevel(1);
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>



</body>
</html>
